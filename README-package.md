# Package [ src/example 예시 ]

## `resolver` [표현] \_\_ 1 계층

**Request HTTP Data 파싱, 세션 관리, 인증/인가, 사용자에게 알맞는 HTTP 데이터 응답, 어떤 응용 서비스를 실행할 것인가?, 응용 서비스에서 던진 에러 제어**

- **절대! 표현 계층에서 도메인 모델에 직접 접근하면 안됩니다!**
- **표현계층에서 사용하는 모든 메서드는 도메인 모델을 직접 리턴하면 안됩니다.**
- 기본적으로 하나의 `resolver`에 모두 작성하되, 표현계층에 API 갯수가 많아진다면 분리를 고려한다.
  1. example-query.resolver.ts -> `@Query()` 만 존재
  2. example-type.resolver.ts -> `@ResolverField()` 만 존재
  3. example-mutation.resolver.ts -> `@Mutation()` 만 존재

## `application` [응용] \_\_ 2 계층

**도메인 객체간 실행 흐름 제어[퍼사드 패턴], 트랜잭션 처리, 접근 제어**

- 응용 서비스 메소드가 한 클래스내에 10개 이상 넘어갈 경우, 클래스 분리 고려
- 표현 계층에서 의존하는 `*.service.ts` 클래스는 `퍼사드 패턴` 중심으로 구현할 것
- 하나의 도메인[한 모듈]의 응용서비스에서 자주 사용되는 클래스들은 `application/lib`폴더에 생성할 것

## `domain` [도메인] \_\_ 3 계층

1.  `entity` [도메인 모델]

    - **도메인 모델이 위치하는 곳**
    - **도메인 모델에 도메인 규칙을 작성합니다.**
    - 모든 기능은 `애그리거트 루트 [ 루트 엔티티 ]` 에 위치
    - B 도메인의 기능이 A 도메인 모델에 존재해선 안된다.
    - 도메인 모델 별 통신은 `이벤트` 를 활용할 것

2.  `service` [도메인 서비스]

    - **2개 이상의 애그리거트를 조합해서 기능을 만들어야 할 때 사용**
    - **1개의 애그리거트 도메인 기능을 합칠때도 사용**
    - 상태없이 로직만 구현한다.
    - 도메인 로직을 수행하지, 응용 로직을 수행하지 않는다 [ 해당 로직이 애그리거트의 상태를 변경(OR)값을 계산하는 지 확인해볼 것 ]
    - 도메인서비스 클래스를 사용하는 곳은 응용서비스/도메인모델 중 하나
    - 도메인 서비스 클래스에서 DI를 하지 않는다. [ 인자로 넘겨줄 것 ]

```
// 한 애그리거트 도메인 기능을 합쳐서 도메인 서비스로 사용
void transfer(Account fromAcc, Account toAcc, Money amounts) {
  fromAcc.withdraw(amounts); // 출금
  toAcc.credit(amounts); // 입금
}
```

## `infra` [인프라스트럭쳐] \_\_ 4 계층

- **실제 기능을 구현하는 곳**

## `dto` [각 계층별 데이터 통신 규격]

- 어떠한 메소드의 `arguement interface[규격]` 를 작성
- interface 없음 / class[OR]type 만

## `interface` [ 각 클래스의 인터페이스 ]

**?? DAO란 무엇인가요?**

- 도메인 모델을 리턴하는 게 아닌, 조회 전용 모델을 리턴하는 `repository` 로 생각하면 됩니다.
- 도메인 모델은 우리가 작성한 `*entity` 파일 / 조회 전용 모델은 `gql`로 생성된 `*Model` 로 생각하면 됩니다.
